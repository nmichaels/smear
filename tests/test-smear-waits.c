/* This file is generated by Smudge. Do not edit it. */
#include <smear/smear.h>
#include "test-smear-waits_ext.h"
#include "test-smear-waits.h"

SRT_HANDLERS(test)

typedef enum test_State
{
    STID_test_this,
    STID_test_that
} test_State;

static test_State test_state = STID_test_this;

static const char *test_State_name(test_State);

static const char *test_Event_name(test_Event_Wrapper);

const char *test_Current_state_name(void);

static void test_UNHANDLED_EVENT_event(const test_event_t *);

static void test_initialize(void);

void test_event(const test_event_t *);

static void test_event_handle(const test_event_t *);

void test_Handle_Message(test_Event_Wrapper);

void test_Free_Message(test_Event_Wrapper);

static void test_this_enter(void);

static void test_this_event(const test_event_t *);

static void test_that_event(const test_event_t *);

static void test_that_enter(void);

static const char *test_State_name(test_State s)
{
    static const char *const state_name[] = {
        "this",
        "that"
    };
    static const unsigned int state_count = sizeof(state_name) / sizeof(const char *);

    return s < state_count ? state_name[s] : "INVALID_STATE";
}

static const char *test_Event_name(test_Event_Wrapper e)
{
    static const char *const event_name[] = {
        "event"
    };
    static const unsigned int event_count = sizeof(event_name) / sizeof(const char *);

    return e.id < event_count ? event_name[e.id] : "INVALID_EVENT";
}

const char *test_Current_state_name(void)
{
    return test_State_name(test_state);
}

static void test_UNHANDLED_EVENT_event(const test_event_t *e)
{
    test_Event_Wrapper wrapper;

    wrapper.id = EVID_test_event;
    wrapper.event.e_event = e;
    SMUDGE_panic_print("test{%s[%s]}: Unhandled event\n", test_State_name(test_state), test_Event_name(wrapper));
}

static void test_initialize(void)
{
    typedef enum init_flag
    {
        UNINITIALIZED,
        INITIALIZED
    } init_flag;
    static init_flag initialized = UNINITIALIZED;

    if(INITIALIZED != initialized) {
        test_state = STID_test_this;
        test_this_enter();
        initialized = INITIALIZED;
    }
}

void test_event(const test_event_t *e)
{
    test_Event_Wrapper wrapper;

    wrapper.id = EVID_test_event;
    wrapper.event.e_event = e;
    test_Send_Message(wrapper);
}

static void test_event_handle(const test_event_t *e)
{
    switch(test_state) {
    case STID_test_that:
        test_that_event(e);
        break;
        
    case STID_test_this:
        test_this_event(e);
        break;
        
    default:
        test_UNHANDLED_EVENT_event(e);
        break;
    }
}

void test_Handle_Message(test_Event_Wrapper wrapper)
{
    test_initialize();
    
    switch(wrapper.id) {
    case EVID_test_event:
        test_event_handle(wrapper.event.e_event);
        break;
        
    default:
        SMUDGE_panic_print("test{%s}: Invalid event ID\n", test_State_name(test_state), "");
        break;
    }
}

void test_Free_Message(test_Event_Wrapper wrapper)
{
    switch(wrapper.id) {
    case EVID_test_event:
        SMUDGE_free(wrapper.event.e_event);
        break;
        
    default:
        SMUDGE_panic_print("test{%s}: Invalid event ID\n", test_State_name(test_state), "");
        break;
    }
}

static void test_this_enter(void)
{
}

static void test_this_event(const test_event_t *e)
{
    (void)e;
    test_state = STID_test_that;
    test_that_enter();
}

static void test_that_event(const test_event_t *e)
{
    (void)e;
    test_state = STID_test_this;
    test_this_enter();
}

static void test_that_enter(void)
{
}
